"""Представление исходного и машинного кода.

Определено два представления:
- Бинарное
"""

import json
from collections import namedtuple
from enum import Enum


class Opcode(str, Enum):
    DROP = "drop"  # Удаляет верхний элемент стека
    DUP = "dup"  # Дублирует верхний элемент стека
    SWAP = "swap"  # Меняет местами два верхних элемента стека
    ADD = "+"  # Складывает два верхних элемента стека
    SUB = "-"  # Вычитает верхний элемент из второго
    MUL = "*"  # Умножает два верхних элемента
    DIV = "/"  # Делит второй элемент на верхний
    MOD = "mod"  # Остаток от деления второго элемента на верхний
    NEGATE = "negate"  # Инвертирует знак верхнего элемента
    EQUAL = "="  # Проверка на равенство
    LESS = "<"  # Проверка: второй < верхнего
    GREATER = ">"  # Проверка: второй > верхнего
    AND = "and"  # Побитовая операция И
    OR = "or"  # Побитовая операция ИЛИ
    XOR = "xor"  # Побитовая операция исключающее ИЛИ
    INVERT = "invert"  # Побитовое НЕ
    IF = "if"  # Начало условия
    EXIT = "exit"  # Завершение выполнения слова
    STORE = "!"  # addr value !
    FETCH = "@"  # addr @
    IN = "in"  # Считывание символа с клавиатуры
    HALT = "halt"  # Останов
    LIT = "lit"  # Ввод числа
    OUT = "out"  # Вывод символа с вершины стека
    JUMP = "jump"  # Переход на метку
    CALL = "call"  # Переход на процедуру
    RET = "ret"  # Возвращение из процедуры
    CARRY = "c"  # Загрузить значение Carry-flag в стек

    def __str__(self):
        return str(self.value)


class Term(namedtuple("Term", "line pos symbol")):
    """Описание выражения из исходного текста программы.

        Сделано через класс, чтобы был docstring.
        """


# Словарь соответствия кодов операций их бинарному представлению
opcode_to_binary = {
    Opcode.DROP: 0x00,
    Opcode.DUP: 0x01,
    Opcode.SWAP: 0x02,
    Opcode.ADD: 0x03,
    Opcode.SUB: 0x04,
    Opcode.MUL: 0x05,
    Opcode.DIV: 0x06,
    Opcode.MOD: 0x07,
    Opcode.NEGATE: 0x08,
    Opcode.EQUAL: 0x09,
    Opcode.LESS: 0x0A,
    Opcode.GREATER: 0x0B,
    Opcode.AND: 0x0C,
    Opcode.OR: 0x0D,
    Opcode.XOR: 0x0E,
    Opcode.INVERT: 0x0F,
    Opcode.IF: 0x10,
    Opcode.STORE: 0x11,
    Opcode.FETCH: 0x12,
    Opcode.IN: 0x13,
    Opcode.HALT: 0x14,
    Opcode.LIT: 0x15,
    Opcode.OUT: 0x16,
    Opcode.JUMP: 0x17,
    Opcode.CALL: 0x18,
    Opcode.RET: 0x19,
    Opcode.CARRY: 0x20,
}

# Словарь соответствия бинарных значений к операциям
binary_to_opcode = {
    0x00: Opcode.DROP,
    0x01: Opcode.DUP,
    0x02: Opcode.SWAP,
    0x03: Opcode.ADD,
    0x04: Opcode.SUB,
    0x05: Opcode.MUL,
    0x06: Opcode.DIV,
    0x07: Opcode.MOD,
    0x08: Opcode.NEGATE,
    0x09: Opcode.EQUAL,
    0x0A: Opcode.LESS,
    0x0B: Opcode.GREATER,
    0x0C: Opcode.AND,
    0x0D: Opcode.OR,
    0x0E: Opcode.XOR,
    0x0F: Opcode.INVERT,
    0x10: Opcode.IF,
    0x11: Opcode.STORE,
    0x12: Opcode.FETCH,
    0x13: Opcode.IN,
    0x14: Opcode.HALT,
    0x15: Opcode.LIT,
    0x16: Opcode.OUT,
    0x17: Opcode.JUMP,
    0x18: Opcode.CALL,
    0x19: Opcode.RET,
    0x20: Opcode.CARRY,
}

def to_bytes(code):
    binary_bytes = bytearray()
    for instr in code:
        opcode_val = opcode_to_binary[instr["opcode"]] & 0xFF  # 8 бит
        arg = instr.get("arg", 0) & 0xFFFFFFFF  # 32 бита

        binary_bytes.append(opcode_val)  # 1 байт
        binary_bytes.extend([
            (arg >> 24) & 0xFF,
            (arg >> 16) & 0xFF,
            (arg >> 8) & 0xFF,
            arg & 0xFF,
        ])  # 4 байта
    return bytes(binary_bytes)




def to_hex(code):
    binary_code = to_bytes(code)
    result = []
    for i in range(0, len(binary_code), 5):  # по 5 байт
        if i + 4 >= len(binary_code):
            break

        opcode_bin = binary_code[i]
        arg = (binary_code[i+1] << 24) | (binary_code[i+2] << 16) | (binary_code[i+3] << 8) | binary_code[i+4]

        opcode = binary_to_opcode.get(opcode_bin)
        if opcode is None:
            mnemonic = f"UNKNOWN_{opcode_bin:02X}"
        else:
            mnemonic = opcode.value
            if opcode in (Opcode.IF, Opcode.LIT, Opcode.JUMP, Opcode.CALL, Opcode.IN, Opcode.OUT):
                mnemonic += f" {arg}"

        hex_word = f"{opcode_bin:02X}{arg:08X}"
        address = i // 5
        line = f"{address} - {hex_word} - {mnemonic}"
        result.append(line)
    return "\n".join(result)




def from_bytes(binary_code):
    structured_code = []
    for line in binary_code.strip().splitlines():
        parts = line.strip().split(" - ")
        if len(parts) < 3:
            continue
        index_str, hex_word, mnemonic = parts
        index = int(index_str)

        if len(hex_word) != 10:  # 2 hex (опкод) + 8 hex (арг)
            raise ValueError(f"Неверная длина hex-слова: {hex_word}")

        opcode_bin = int(hex_word[:2], 16)
        arg = int(hex_word[2:], 16)

        opcode = binary_to_opcode.get(opcode_bin)
        if opcode is None:
            raise ValueError(f"Неизвестный бинарный код операции: {opcode_bin:#X} в строке: {line}")

        instr = {"index": index, "opcode": opcode}
        if opcode in (Opcode.IF, Opcode.LIT, Opcode.JUMP, Opcode.CALL, Opcode.IN, Opcode.OUT):
            instr["arg"] = arg
        structured_code.append(instr)
    return structured_code


