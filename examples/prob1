_start:
    lit 0   ; адрес первого числа
    lit 990 ; начальное число для итерации первого числа
    !
    lit 1   ; адрес второго числа
    lit 913 ; начальное число для итераций второго числа
    !
    lit 2   ; адрес для палиндрома
    lit 0   ; первоначальное значение
    !
    lit 4   ; переменная для индекса массива цифр числа
    lit 6   ; начальный индекс - 6
    !
    lit 5   ; дополнительная переменная для индекса массива цифр числа
    lit 6   ; начальный индекс - 6
    !
while:
    lit 0 @
    lit 1 @ ; загрузим оба числа для умножения
    *
    lit 3   ; адрес буфера для сохранения слова
    swap
    !       ; сохранение в буфер
    jump palindrome_save ; проверим, является ли число палиндромом
palindrome_save:
    lit 3 @ ; берем число, которое будем проверять
    dup
    lit 10
    swap
    mod
    lit 4 @ ; берем индекс
    swap
    !       ; сохраняем
    lit 10  ; загружаем 10 для целочисленного деления
    swap
    /
    dup
    if palindrome_check
    lit 3
    swap
    !       ; сохраняем результат без последней цифры
    lit 4
    dup
    @
    lit 1
    +
    !       ; сохраняем переменную для индекса, увеличенную на 1
    jump palindrome_save
palindrome_check:
    lit 4 @ @   ; возьмем крайнее левое число массива
    lit 5 @ @   ; возьмем крайнее правое число массива
    =
    if prep_while   ; увеличим числа, которые будем перемножать
    lit 1   ; уменьшим счетчик крайнего правого числа массива
    lit 4 @
    -
    lit 4
    swap
    !       ; сохраним новое значение
    lit 1   ; увеличим счетчик крайнего левого числа массива
    lit 5 @
    +
    lit 5
    swap
    !       ; сохраним новое значение
    lit 1
    lit 4 @
    lit 5 @
    =       ; если индексы совпали, то число - палиндром
    -
    if save1
    lit 4 @
    lit 5 @
    <       ; если индексы поменялись по величине друг с другом, то число - палиндром
    if save1
    jump palindrome_check
save1:
    lit 0 @
    lit 1 @
    *       ; легче посчитать заново, чес сохранять в памяти числа...
    dup
    lit 2 @
    swap
    <       ; если найденный палиндром меньше прошлого, то отбрасываем его
    if save
    jump prep_while
save:
    lit 2
    swap
    !       ; сохраним полином
    lit 12
    lit 0 @
    !
    lit 13
    lit 1 @
    !       ; сохраним его множители в память
prep_while:
    lit 4   ; переменная для индекса массива цифр числа
    lit 6   ; начальный индекс - 6
    !
    lit 5   ; дополнительная переменная для индекса массива цифр числа
    lit 6   ; начальный индекс - 6
    !
    lit 999 ; если первый множитель ушел за 999, заканчиваем
    lit 0 @
    <
    if end
    lit 1
    lit 990 ; если второй множитель ушел за 990, прибавляем к первой единицу
    lit 1 @
    =
    -
    if plus_x
    lit 1   ; увеличим второй множитель на 11
    dup @
    lit 11
    +
    !
    jump while  ; возврат в первоначальный цикл
plus_x:
    lit 0   ; увеличиваем первое слагаемое и сбрасываем до 110 второе
    dup @
    lit 1 +
    !
    lit 1
    lit 110
    !
    jump while
end:
    lit 14 ; загрузим в память получившийся палиндром
    lit 2 @
    !
    halt